# 类加载

- 在Java代码中,类型的==加载==、连接与初始化过程都是在程序运行期间完成的
- 提供了更大的灵活性,增加了更多的可能性

------------------

注:类型是代表的class,比如int类型,object类型而不是new一个对象

-------------------

## 一.Java虚拟机与程序的生命周期

在如下几种情况下,Java虚执机将结束生命周期

1. 执行了 System.exit0)方法
2. 程序正常执行结束
3. 程序在执行过程中遇到了异常或错误而异常终止
4. 由于操作系统出现错误而导致Java虚拟机进程终止

## 二.类的加载,连接与初始化

- 加载:查找并加载类的二进制数据
- 连接
  - 验证:确保被加载的类的正确性
  - 准备:为类的==静态变量==分配内存,并将其初始化为==默认值==
  - 解析:==把类中的符号引用转换为直接引用==
- 初始化:为类的静态变量赋予正确的初始值

### 1.Java程序对类的使用方式

主动使用

被动使用

**所有的Java虚拟机实现必须在每个类或者接口被Java程序==首次主动使用==时才初始化它们**

#### 1).主动使用

- 创建类的实例
- 访问某个类或者接口的静态变量,或者对 该静态变量赋值
- 调用类的静态方法
- 反射
- 初始化一个类的子类
- Java虚拟机启动时被标明为启动类的类
- JDK1.7开始提供的动态语言支持java. langinvoke. Method Handle'实例的解析结ERREF getstatic, REF putstatic,REF invoke Static句柄对应的类没有初始化,则初始化

#### 2).被动使用

除了上述的情况,其他使用Java类的方式都被看做是对类的被动使用,都不会导致类的初始化

--------------------

第一例

``` java
public Mytest {
    public static void main(String[] args){
        System.out.println(MyChild.str);
    }
}
class Myparent{
    public static String str="hello world";
    static {
        System.out.println("Myparent static block");
    }
}
class MyChild extends Myparent{
    public static String str2="welcome";
    static {
        System.out.println("MyChild static block");
    }
}
//打印结果
Myparent static block
hello world
```

第二例

``` java
public Mytest {
    public static void main(String[] args){
        System.out.println(MyChild.str2);
    }
}
//结果
Myparent static block
MyChild static block
welcome
```

**原因:** 对于静态字段而言,只有定义了该字段的类才会被初始化(主动使用)

所以在第一个例子中,调用的是str字段而该字段是属于父类的,所以没有打印Mychild的静态代码块(因为它没有被主动使用,不会去初始化Mychild的类);

在第二个例子中,主动使用了Mychild类,但是由于使用了Myparent的子类,因此Myparent类也被主动使用了;所以两个类都被初始化了;

------------------

### 2.类的加载

类的加载指的是将类的. class文件中的二进制数据读入到内存中,将其放在运行时数据区的方法区内,然后在内存中创建一个jva. lang Classx对象(规范并未说明 Class对象位于哪里, Hotspot虚拟机将其放在了方法区中)用来封装类在方法区内的数据
结构

#### 1).加载class文件的方式

- 从本地系统中直接加载
- 通过网络下载class文件
- 从zip,jar等归档文件中加载class文件
- 从专有的数据库中提取class文件
- ==将Java源文件动态编译为class文件==





